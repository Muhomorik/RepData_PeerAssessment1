---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---


## Loading and preprocessing the data

The research dataset zip file should be in the current working directory or it will be downloaded and unzipped to the current working directory from the [webpage][1].

Remember to set the working directory.

```{r load echo=TRUE}

setwd("~/R Projects/Coursera/5 - Reproducible Research/RepData_PeerAssessment1")
rm(list=ls())

# Load packages
library(dplyr)
library(ggplot2)

# Download uri.
data.url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"
data.url <- gsub("%2F", "/", data.url)

file.zip <- "activity.zip"
file.data <- "activity.csv"

# Download file if missing.
if (!file.exists(file.zip)){
  message("Downloading file into: ", getwd())
  download.file(data.url, file.zip, method = "auto", mode="wb") # Don't use curl on Windows.
  unzip(file.zip)
}

# Load into df and set correct column types. Remove NA's.
activity <- read.csv(file.data) %>%
  mutate(date = as.Date(date)) %>%
  mutate(steps = as.integer(steps)) %>%
  mutate(interval = as.integer(interval))


```

## What is mean total number of steps taken per day?

Before creating a histogramm remove NA values and group dataframe by date. Apply
the sum() function to $steps.

```{r MeanMedPerDay_calc echo=TRUE}
summ.byDate <- activity %>%
  na.omit() %>% # 15264 left
  group_by(date) %>%
  summarise(
    steps = sum(steps))

```

Draw a histogram for steps.

```{r MeanMedPerDay_hist echo=TRUE}
hist(summ.byDate$steps,
     col = "aquamarine3",
     main="Steps per day",
     xlab="Steps")

```

Calculate the mean and median for values.

```{r MeanMedPerDay_MeanMed echo=TRUE}
steps.mean <- mean(summ.byDate$steps)
steps.median <- median(summ.byDate$steps)
```

The *mean* total number of steps taken per day is `r steps.mean` and the 
*median* is `r steps.median`.

## What is the average daily activity pattern?

Remove NA's and calculate the mean of steps over all days by time interval.

```{r DailyAverage_calc echo=TRUE}
average.byInterval <- activity %>%
  na.omit() %>% # 15264 left
  group_by(interval) %>%
  summarise(
    steps = mean(steps))
```

Plot the results as time series.

```{r DailyAverage_chart echo=TRUE}

plot(average.byInterval$interval, average.byInterval$step,
  type="l",
  main="Average number of steps per interval",
  xlab="Interval", 
  ylab="Steps mean"
)

```


Find interval which contains the maximum of steps. The result is a frame of
interval and steps. Because there can be multiple rows with results (max value is
in more than one interval) and the conflict resolving strategy is not specified 
only the first result is taken.


```{r DailyAverage_values echo=TRUE}

average.Max <- average.byInterval  %>%
  filter(steps == max(steps)) %>%
  filter(row_number() == 1)

average.Max$interval
average.Max$steps

```

The interval with the maximum ammount of steps is `r average.Max$interval` and the average 
number of steps inside that interval is `r average.Max$steps`.

## Imputing missing values

The total number of missing values in the dataset (i.e. the total number of rows with NAs).
Filter NA rows and count the number of observations in the current group with n().
Fix the column name in resulting frame.

```{r nas_values echo=TRUE}

nas.cnt <- activity  %>%
  filter(is.na(steps)) %>%
  summarise(n()) %>%
  rename(n = `n()`)
nas.cnt$n
```

There are `r nas.cnt$n` NA values in the set.


### Filling minning values ###

The strategy uses already calculated values inside the frame is 
to replace the missing values by the mean value from the given interval, like
inside the *average.byInterval* data frame..

Note: If-else syntax is different for dplyr, *ifelse(test, yes, no)*.

```{r nas_fill echo=TRUE}

activity.filled <- activity  %>%
  group_by(interval) %>%
  mutate(steps = replace(steps, is.na(steps), mean(steps, na.rm=TRUE)))

```

New sum of steps calculated with NA values replaced by mean.

```{r nas_MeanMedPerDay_calc echo=TRUE}

summ.byDateFilled <- activity.filled %>%
  group_by(date) %>%
  summarise(
    steps = sum(steps))

```

Draw a histogram for steps with new NA's.

```{r nas_MeanMedPerDay_hist echo=TRUE}

hist(summ.byDateFilled$steps,
     col = "aquamarine3",
     main="Steps per day, NA filled",
     xlab="Steps")

```

Calculate the mean and median for values.

```{r nas_MeanMedPerDay_MeanMed echo=TRUE}

stepsFilled.mean <- mean(summ.byDateFilled$steps)
stepsFilled.median <- median(summ.byDateFilled$steps)

```

The *mean* total number of steps taken per day has changed form `r steps.mean` to  
`r stepsFilled.mean` and the *median* is changed from `r steps.median` to `r stepsFilled.median`.
Basically, the median of data is changed but mean remain the same.
Char shows that data distribution is around the center.


## Are there differences in activity patterns between weekdays and weekends?

Add new column *day* with Weekday as a decimal number (1-7, Monday is 1). Then
replace day nubmers >6 with *weekend* and other days with *weekday*. Filled NA values
are used.

```{r days_mod echo=TRUE}

activityFilled_days <- activity.filled  %>%
  mutate(day = strftime(date,'%u')) %>%
  mutate(day = ifelse(day > 6, "weekend", "weekday")) %>%
  select(steps, interval, day) %>%
  group_by(interval, day) %>%
  summarise(steps = mean(steps))

```

Plot data using ggplot2 with horizontal facets.

```{r days_chart echo=TRUE}

days.plot <-
  ggplot(activityFilled_days, aes(interval, steps, fill=steps)) +
  geom_freqpoly(stat="identity") + 
  theme_bw() + # White background with grid lines.
  guides( fill=FALSE ) + # skip legend.
  facet_grid(day~., scales = "free", space="free") +
  labs(x = "interval", y = "Average nr of steps") + 
  labs(title = "Average number of steps taken weekday/weekend") +
  theme(text = element_text(size=12)) # Smaller font or will overlap in file.

print(days.plot) # screen, Plots tab.

```


[1]: https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip
